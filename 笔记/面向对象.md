# 封装、抽象、继承、多态分别可以解决哪些编程问题？

## 封装（Encapsulation）

隐藏信息、保护数据

封装的特性：

- 封装就是隐藏属性，通过暴露有限的接口供外部访问

封装需要访问权限控制：

- 例如public，private也是因为有了这些 控制权限的语法 才有了封装的概念。

封装的意义：

- 防止代码过度“灵活”，即可控性。
- 暴露有限的方法，提高类的易用性。因为暴露出的方法少了。

## 抽象（Abstraction）

抽象是一种思维

隐藏方法的具体实现

抽象的实现：

- interface 关键字
- abstract 抽象类	

抽象的意义：

- 抽象是为了简化，降低复杂性。

## 继承（Inheritance）

继承是用来表示类之间的 is-a 关系

继承的实现： 

- extends 关键字

继承的意义：

- 代码复用

继承的注意点

- 继承层次过深过复杂，会导致代码可读性、可维护性变差

## 多态（Polymorphism）

多态是指，子类可以替换父类

多态需要语法机制支持：

- 支持父类对象可以引用子类对象
- 编程语言要支持继承
- 编程语言要支持子类可以重写（override）父类中的方法

多态的实现： 

- 继承加方法重写
- 接口类语法

多态的意义：

- 多态特性能提高代码的可扩展性和复用性（子类的）
- 将不同类型传给相同函数

# 面向对象相比面向过程有哪些优势？

## 什么是面向过程编程？什么是面向过程编程语言？

- 面向过程最主要的特点：数据和方法相分离。
- 面向过程编程语言最大的特点：不支持丰富的面向对象编程特性，比如继承、多态、封装。

## 面向对象编程相比面向过程编程有哪些优势？

- 对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
- 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
- 从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。

# 哪些代码设计看似是面向对象，实际是面向过程的？
滥用 getter、setter 方法
- 滥用get,set面向对象封装的定义是：通过权限访问，当写完直接顺手全写getset，这样都可以访问当内部的数据并修改，这样就退化成面向过程了。
- 当元素是集合的时候，即使是get也会退化成面向过程，因为他返回的是一个List集合容器，list容器的内容也是可以被修改的。
- list 可以使用 Collections.unmodifiableList() 进制修改list。 
  
滥用全局变量和全局方法
- java 中常见的全局变量有 单例对象，静态变量，常量等
- 静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
- 常量类的弊处:1常量多变得不好维护。2编译耗时。3代码不好复用，有时为了一个变量引入一个类
- 工具类，能让多个类使用，提高代码复用率
- 只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格

定义数据和方法分离的类
- 贫血模型的开发模式
- 这数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的

# 接口vs抽象类的区别？如何用普通的类模拟抽象类和接口
- 接口与抽象类都能实现多态，抽象特性，抽象类：一个类继承抽象类，这两个类存在上下关系，接口：接口则是对行为的抽象，一个类实现一个接口，只是这个类具有了这个接口的功能，但是这二者可以没有上下的层级关系
  
什么是抽象类和接口？区别在哪里？

抽象类
- java 中的抽象类：Logger 抽象类   FileLogger 和 MessageQueueLogger 继承 Logger 分别实现不同日志方式，可以复用父类中的方法
- 抽象类只能被继承不能实例化
- 抽象类可以包含属性和方法,方法可以实现可以不实现，不实现的方法叫做抽象方法。
- 子类继承抽象类，必须实现抽象类中的所有抽象方法

接口
- interface 关键字定义接口
- 接口不能包含属性（也就是成员变量）。
- 接口只能声明方法，方法不能包含代码实现。
- 类实现接口的时候，必须实现接口中声明的所有方法。
- 从jdk1.8开始 接口可以加入default方法了

抽象类和接口的区别
- 抽象类是 is-a 的继承关系
- 接口是 has-a 的包含关系(协议)
- 抽象类是一种自下而上的设计思路
- 接口，是一种自上而下的设计思路
  
抽象类和接口能解决什么编程问题？

抽象类
- 1.代码复用 
- 2.优雅的多态实现方式
- 3.类+继承能够实现复用，抽象+类+继承，复用+多态

接口
- 1.接口就侧重于解耦

# “基于接口而非实现编程”中的接口该如何理解
- 要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。
- 在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

# 为何说要多用组合少用继承？如何决定该用组合还是继承？
- 组合优于继承，多用组合少用继承。

为什么不推荐使用继承？
- 继承表示类的 is-a 关系，可以解决代码复用的问题。如果继承层次过深、过复杂，会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

组合相比继承有哪些优势？
- 继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

如何判断该用组合还是继承？
- 如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承
- 接口+组合+委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。

# 业务开发常用的基于贫血模型的MVC架构违背OOP吗？
什么是贫血模型？什么是充血模型？
- 只包含数据，不包含业务逻辑的类，称为贫血模型
  - 贫血模型中，Service层有service类和BO类，BO类只包含数据
- 数据与业务逻辑都包含的类，成为充血模型
  - 充血模型中，Service层有service类和Domin类，Domin类既包含数据又包含业务逻辑

为什么说基于贫血模型的传统开发模式违反 OOP?
- 基于贫血模型的开发模式，其实是面向过程的编程思想。

基于贫血模型的传统开发模式既然违反 OOP，那又为什么如此流行？
- 业务逻辑简单，贫血模型与充血模型应用后差别不大。
- 贫血模型的开发模式是只需定义数据，后需要什么需求再在service层写什么操作的业务逻辑，渐次扩充。充血模型的开发模式是先定义业务逻辑，需要暴露哪些操作。
- 惯性转型痛点

什么情况下我们应该考虑使用基于充血模型的 DDD 开发模式？
- 越复杂的系统，对代码的复用性、易维护性要求就越高这时候就可以使用 DDD 的开发模式
- 简单的系统可以使用贫血模型

所有的中间层都是为了解耦
基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。
这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。
两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。
所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。