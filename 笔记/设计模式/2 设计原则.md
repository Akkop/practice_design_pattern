# 对于单一职责原则，如何判定某个类的职责是否够“单一”？

如何理解单一职责原则（SRP）？

SOLID 原则由五个原则组成

- 单一职责原则S
- 开闭原则O
- 里氏替换原则L
- 接口隔离原则I
- 依赖反转原则D



一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

描述对象

1. 类
2. 模块

把模块看作比类更加抽象的概念，类也可以看作模块、

把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

如何判断类的职责是否足够单一？

类拆分

1. 类中的代码行数、函数或者属性过多；
2. 类依赖的其他类过多，或者依赖类的其他类过多；
3. 私有方法过多；
4. 比较难给类起一个合适的名字；
5. 类中大量的方法都是集中操作类中的某几个属性。

类的职责是否设计得越单一越好？

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。



内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。

耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合。



# 如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

SOLID 原则由五个原则组成

- 单一职责原则S
- 开闭原则O
- 里氏替换原则L
- 接口隔离原则I
- 依赖反转原则D

如何理解“对扩展开放、对修改关闭”？

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。

关于定义，我们有两点要注意。

第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。

第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。



如何做到“对扩展开放、修改关闭”？

我们要时刻具备扩展意识、抽象意识、封装意识。

在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。

特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。

最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。



# 里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？

SOLID 原则由五个原则组成

- 单一职责原则S
- 开闭原则O
- 里氏替换原则L
- 接口隔离原则I
- 依赖反转原则D

里氏替换原则

 -- 按照协议来设计

氏替换就是子类完美继承父类的设计初衷，并做了增强对

LSP的意义：
一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用LSP实现更高效的排序算法。
二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合contract。
三、改进抽象设计。如果一个子类中的实现违反了LSP，那么是不是考虑抽象或者设计出了问题。

# 接口隔离原则有哪三种应用？原则中的“接口”该如何理解？

SOLID 原则由五个原则组成

- 单一职责原则S
- 开闭原则O
- 里氏替换原则L
- 接口隔离原则I
- 依赖反转原则D

接口隔离原则

对于‘接口’的理解不同将有不同的结果。

- 接口 ： 一组接口集合 

  如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口2.

- 接口： 单个 API 接口或函数

  部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。

- 接口： OOP 中的接口

  接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

  

接口隔离原则与单一职责原则的区别

- 单一职责原则针对的是模块、类、接口的设计
- 接口隔离原则侧重接口设计



- 接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定
- 如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。



# 控制反转、依赖反转、依赖注入，这三者有何区别和联系？

SOLID 原则由五个原则组成

- 单一职责原则S
- 开闭原则O
- 里氏替换原则L
- 接口隔离原则I
- 依赖反转原则D



控制反转

控制反转是笼统的概念，用于指导框架层面的设计。正常程序执行流程是由程序员管理，反转即交给框架管理



依赖注入

不使用 new 在类内部创建依赖对象。需要依赖的对象在外部创建好，通过构造函数，构造参数等等传递(或注入)给类使用



依赖注入框架

通过依赖注入框架提供的扩展点，简单配置所需要类及其与其他类之间的依赖关系，就可以使用框架自动创建对象，管理对象的生命周期，依赖注入等等原先由程序员来做的事情



依赖反转原则

高层模块不依赖底层模块，他们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

只要是从外部传入不是在内部new出来都可以称为依赖注入。



# 我为何说KISS、YAGNI原则看似简单，却经常被用错？

KISS 原则

尽量保持简单。

YAGNI原则

不要做过度设计



KISS原则保持代码可读，可维护的重要手段，简单不是指行数少，要考量逻辑复杂度，实现难度，代码可读性。

复杂问题使用复杂解法，不违背KISS原则，不同业务场景下，也可能产生不同的结果。



对于如何写出满足 KISS 原则的代码，我还总结了下面几条指导原则：

- 不要使用同事可能不懂的技术来实现代码；
- 不要重复造轮子，要善于使用已经有的工具类库；
- 不要过度优化。

# 重复的代码就一定违背DRY吗？如何提高代码的复用性？

三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。

实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。

实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。

除此之外，代码执行重复也算是违反 DRY 原则。



怎么提高代码复用性

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装

# 如何用迪米特法则（LOD）实现“高内聚、松耦合”？

如何理解“高内聚、松耦合“

- “高内聚”用来指导类本身的设计
- “松耦合”用来指导类与类之间依赖关系的设计

高内聚、松耦合 能够做什么

- 能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围



高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中

松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动



如何理解“迪米特法则

- 不该有直接依赖关系的类之间，不要有依赖
- 有依赖关系的类之间，尽量只依赖必要的接口。

1.单一职责原则
适用对象:模块，类，接口
侧重点:高内聚，低耦合
思考角度:自身

2.接口隔离原则
适用对象:接口，函数
侧重点:低耦合
思考角度:调用者

3.基于接口而非实现编程
适用对象:接口，抽象类
侧重点:低耦合
思考角度:调用者

4.迪米特法则
适用对象:模块，类
侧重点:低耦合
思考角度:类关系